#lang rosette/safe

(define (ub-b b f)
  (define-symbolic* w integer?)
  (forall (list w) (=> (f w) b)))

(define (test-ub)
  (define (f n) (> n 0))
  (define (g n) (> n n))
  (define (h n) (= n n))
  (define (m n) (list? (member n (list 2 4 5))))

  (list
  (verify (assert (ub-b #t f)))
  (verify (assert (! (ub-b #f f))))
  (verify (assert (ub-b #t h)))
  (verify (assert (! (ub-b #f h))))
  (verify (assert (ub-b #f g)))
  (verify (assert (ub-b #t g)))
  (verify (assert (ub-b #t m)))
  (verify (assert (! (ub-b #f m))))))

(define (lub-b lb f)
  (define-symbolic* b boolean?)
  (&&
   (ub-b lb f)
   (forall (list b)
           (=> (ub-b b f)
               (=> lb b)))))

(define (test-lub)
  (define (f n) (> n 0))
  (define (g n) (> n n))
  (define (h n) (= n n))
  (define (m n) (list? (member n (list 2 4 5))))

  (list
  (verify (assert (lub-b #t f)))
  (verify (assert (! (lub-b #f f))))
  (verify (assert (lub-b #t h)))
  (verify (assert (! (lub-b #f h))))
  (verify (assert (lub-b #f g)))
  (verify (assert (! (lub-b #t g))))
  (verify (assert (lub-b #t m)))
  (verify (assert (! (lub-b #f m))))))

(struct trop (i n) #:transparent)

(define (to-trop b)
  (if b (trop #f 0) (trop #t 1)))

(assert (eq? (trop #f 0) (to-trop #t)))
(assert (eq? (trop #t 1) (to-trop #f)))

;; min
(define (t+ x y)
  (if (trop-i x)
      y
      (if (trop-i y)
          x
          (trop #f (min (trop-n x)
                        (trop-n y))))))

(assert (eq? (t+ (trop #t 1) (trop #t 1)) (trop #t 1)))
(assert (eq? (t+ (trop #t 1) (trop #f 1)) (trop #f 1)))
(assert (eq? (t+ (trop #f 1) (trop #t 1)) (trop #f 1)))
(assert (eq? (t+ (trop #f 1) (trop #f 2)) (trop #f 1)))

;; +
(define (t* x y)
  (if (trop-i x)
      (trop #t 1)
      (if (trop-i y)
          (trop #t 1)
          (trop #f (+ (trop-n x)
                      (trop-n y))))))

(assert (eq? (t* (trop #t 1) (trop #t 1)) (trop #t 1)))
(assert (eq? (t* (trop #t 1) (trop #f 1)) (trop #t 1)))
(assert (eq? (t* (trop #f 1) (trop #t 1)) (trop #t 1)))
(assert (eq? (t* (trop #f 1) (trop #f 2)) (trop #f 3)))

;; <=
(define (t>= x y)
  (if (trop-i y)
      #t
      (if (trop-i x)
          #f
          (<= (trop-n x) (trop-n y)))))

(assert (t>= (trop #f 5) (trop #t 1)))
(assert (! (t>= (trop #t 1) (trop #f 5))))
(assert (t>= (trop #f 5) (trop #f 6)))
(assert (t>= (trop #t 5) (trop #t 1)))

;; b is an upperbound of f(w)

(define (trop-ub b f)
  (define-symbolic* m integer?)
  (forall (list m) (t>= b (f m))))

(define (test-trop-ub)
  (define (f n) (trop #f n))
  (define (g n) (trop #f (abs n)))
  (define (h n) (trop #f (* n n)))
  (define (i n) (trop #t 1))
  (define (m n) (to-trop (list? (member n (list 2 4 5)))))

  (list
  (verify (assert (! (trop-ub (trop #f 1) f))))
  (verify (assert (! (trop-ub (trop #t 1) f))))

  (verify (assert (! (trop-ub (trop #t 1) g))))
  (verify (assert (! (trop-ub (trop #f 1) g))))
  (verify (assert (trop-ub (trop #f 0) g)))
  (verify (assert (trop-ub (trop #f -1) g)))

  (verify (assert (! (trop-ub (trop #t 1) h))))
  (verify (assert (! (trop-ub (trop #f 1) h))))
  (verify (assert (trop-ub (trop #f 0) h)))
  (verify (assert (trop-ub (trop #f -1) h)))

  (verify (assert (trop-ub (trop #t 1) i)))
  (verify (assert (trop-ub (trop #f 1) i)))
  (verify (assert (trop-ub (trop #f 0) i)))
  (verify (assert (trop-ub (trop #f -1) i)))

  (verify (assert (trop-ub (trop #t 1) i)))
  (verify (assert (trop-ub (trop #f 2) i)))
  (verify (assert (trop-ub (trop #f 3) i)))
  (verify (assert (trop-ub (trop #f -1) i)))))

;; lb is a lub of f

(define (trop-lub lb f)
    (define-symbolic* n integer?)
    (define-symbolic* i boolean?)
    (&& (trop-ub lb f)
        (forall (list i n)
                (=> (trop-ub (trop i n) f)
                    (t>= (trop i n) lb)))))

(define (test-trop-lub)
  (define (f n) (trop #f n))
  (define (g n) (trop #f (abs n)))
  (define (h n) (trop #f (* n n)))
  (define (i n) (trop #t 1))
  (define (m n) (to-trop (list? (member n (list 2 4 5)))))

  (list
  (verify (assert (! (trop-lub (trop #f 1) f))))
  (verify (assert (! (trop-lub (trop #t 1) f))))

  (verify (assert (! (trop-lub (trop #t 1) g))))
  (verify (assert (! (trop-lub (trop #f 1) g))))
  (verify (assert (trop-lub (trop #f 0) g)))
  (verify (assert (! (trop-lub (trop #f -1) g))))

  (verify (assert (! (trop-lub (trop #t 1) h))))
  (verify (assert (! (trop-lub (trop #f 1) h))))
  (verify (assert (trop-lub (trop #f 0) h)))
  (verify (assert (! (trop-lub (trop #f -1) h))))

  (verify (assert (trop-lub (trop #t 1) i)))
  (verify (assert (! (trop-lub (trop #f 1) i))))
  (verify (assert (! (trop-lub (trop #f 0) i))))
  (verify (assert (! (trop-lub (trop #f -1) i))))

  (verify (assert (trop-lub (trop #t 1) i)))
  (verify (assert (! (trop-lub (trop #f 2) i))))
  (verify (assert (! (trop-lub (trop #f 3) i))))
  (verify (assert (! (trop-lub (trop #f -1) i))))))

;; E(x,y) * sum_w R(x,y,w) = sum_w E(x,y) * R(x,y,w)

;; sum_w S(x,y,w) + (R(x,y,w) = sum_w S(x,y,w) + sum_w R(x,y,w)

(define (E*s_wR E R)
  (define (f x y)
    (define-symbolic* min-w integer?)
    (assert (trop-lub (trop #f min-w)
                      (lambda (w) (trop #f (R x y w)))))
    (+ (E x y)
       min-w))
  f)

(define (test-s1)
  (define (E x y) (+ x y))
  (define (R x y w) (+ x y (* (+ 2 w) w)))
  (define out ((E*s_wR E R) 4 2))
  (define sol (solve #t))
  (assert (= 30 (evaluate out sol))))

(define (s_wE*R E R)
  (define (f x y)
    (define (f0 w)
      (trop #f (+ (E x y) (R x y w))))
    (define-symbolic* min-w integer?)
    (assert (trop-lub (trop #f min-w) f0))
    min-w)
  f)

(define (test-s2)
  (define (E x y) (+ x y))
  (define (R x y w) (+ x y (* (+ 2 w) w)))
  (define out ((s_wE*R E R) 4 2))
  (define sol (solve #t))
  (assert (= 30 (evaluate out sol))))

(define (test-*sum)
  (define-symbolic E (~> integer? integer? integer?))
  (define-symbolic R (~> integer? integer? integer? integer?))
  (define-symbolic x y integer?)
  (define r1 ((E*s_wR E R) x y))
  (define r2 ((s_wE*R E R) x y))
  (verify (assert (= r1 r2))))

(define (s_wR+s_wS R S)
  (define (f x y)
    (define-symbolic* min-w1 min-w2 integer?)
    (assert (trop-lub (trop #f min-w1)
                      (lambda (w) (trop #f (R x y w)))))
    (assert (trop-lub (trop #f min-w2)
                      (lambda (w) (trop #f (S x y w)))))
    (min min-w1 min-w2))
  f)

(define (s_wR+S R S)
  (define (f x y)
    (define-symbolic* min-w integer?)
    (assert (trop-lub (trop #f min-w)
                      (lambda (w) (trop #f (min (S x y w)
                                                (R x y w))))))
    min-w)
  f)

(define (test-+sum)
  (define-symbolic R S (~> integer? integer? integer? integer?))
  (define-symbolic x y integer?)
  (define r1 ((s_wR+s_wS R S) x y))
  (define r2 ((s_wR+S R S) x y))
  (verify (assert (= r1 r2))))

;; trivial: x = MIN_w 1_{x=w} + w

(define (s_w1_x=q+w x w)
  (define-symbolic* min-w integer?)
  (assert (trop-lub (trop #f min-w)
                    (lambda (w)
                      (t* (trop #f w)
                          (to-trop (= x w))))))
  min-w)

(define (test-trivial)
  (define-symbolic w x integer?)
  (define r (s_w1_x=q+w x w))
  (verify (assert (= r x))))

;; to_trop any_b R(b) = sum_b to_trop R(b)

(define (trop_any_bRb R)
  (define (f b)
    (define-symbolic* any-b boolean?)
    (assert (lub-b any-b R))
    (to-trop any-b))
  f)

(define (sum_b_trop_Rb R)
  (define (f b)
    (define-symbolic* min-b integer?)
    (assert (trop-lub (trop #f min-b)
                      (lambda (b)
                        (to-trop (R b)))))
    (trop #f min-b))
  f)

(define (test-any-min)
  (define-symbolic* b integer?)
  (define-symbolic* R (~> integer? boolean?))
  (define r1 ((trop_any_bRb R) b))
  (define r2 ((sum_b_trop_Rb R) b))
  (verify (assert (eq? r1 r2))))

;; sum_w (to-trop any_b R(b))* S(w) = sum_b R(b) * sum_w S(w)

(define (s_w_a_bR*S R S)
  (define (f)
    (define (f0 w)
      (define-symbolic* any-b boolean?)
      (assert (lub-b any-b R))
      (t* (trop #f (S w)) (to-trop lub-b)))
    (define (f1)
      (define-symbolic* min-w integer?)
      (assert (trop-lub (trop #f min-w) f0))
      min-w)
    (f1))
  f)

(define (s_bR*s_wS R S)
  (define (f)
    (define-symbolic* min-b min-w integer?)
    (assert (trop-lub (trop #f min-b)
                      (lambda (b) (to-trop (R b)))))
    (assert (trop-lub (trop #f min-w)
                      (lambda (w) (trop #f (S w)))))
    (+ min-b min-w))
  f)

(define (test-any-min-nest)
  (define-symbolic* R (~> integer? boolean?))
  (define-symbolic* S (~> integer? integer?))
  (define r1 ((s_w_a_bR*S R S)))
  (define r2 ((s_bR*s_wS R S)))
  (verify (assert (eq? r1 r2))))

;; MIN_w to-trop(ANY_u R(w,u))* w = MIN_w,u to-trop(R(w,u)*w)

(define (S-17 R)
  (define (f)
    (define (f1 w)
      (define-symbolic any-u (~> integer? boolean?))
      (assert (lub-b (any-u w) (lambda (u) (R w u))))
      (t* (to-trop (any-u w))(trop #f w)))
    (define (f2)
      (define-symbolic min-w integer?)
      (assert (trop-lub (trop #f min-w) f1))
      min-w)
    (f2))
  f)

(define (S-18 R)
  (define (f)
    (define (f0 w u)
      (t* (trop #f w) (to-trop (R w u))))
    (define (f1 w)
      (define-symbolic min-u (~> integer? integer?))
      (assert (trop-lub (trop #f (min-u w))
                        (lambda (u) (f0 w u))))
      (trop #f (min-u w)))
    (define (f2)
      (define-symbolic min-w integer?)
      (assert (trop-lub (trop #f min-w) f1))
      min-w)
    (f2))
  f)

(define (test-17-18)
  (define-symbolic R (~> integer? integer? boolean?))
  (define r1 ((S-17 R)))
  (asserts)
  #;(define r2 ((S-18 R)))
  #;(verify (assert (eq? r1 r2))))

(test-17-18)

;; (list
;;  (&& (forall (m$0) (|| (! (app any-u m$0))
;;                        (&& (app any-u m$0) (<= min-w (ite (app any-u m$0)
;;                                                           (+ m$0 (ite (app any-u m$0) 0 1))
;;                                                           1)))))
;;      (forall (i$0 n$0) (|| (&& (! i$0) (<= n$0 min-w))
;;                            (! (forall (m$1) (|| (! (app any-u m$1)) (&& (app any-u m$1) (&& (! i$0) (<= n$0 ...)))))))))
;;  (&& (forall (w$2) (|| (app any-u m$1)
;;                        (! (app R m$1 w$2))))
;;      (forall (b$1) (|| (|| b$1 (! (app any-u m$1))) (! (forall (w$3) (|| b$1 (! (app R m$1 w$3))))))))
;;  (&& (forall (w$0) (|| (app any-u m$0)
;;                        (! (app R m$0 w$0))))
;;      (forall (b$0) (|| (|| b$0 (! (app any-u m$0))) (! (forall (w$1) (|| b$0 (! (app R m$0 w$1)))))))))

;; (list
;;  (&& (forall (m$0) (|| (! any-u)
;;                        (&& any-u
;;                            (<= min-w (ite any-u
;;                                           (+ m$0 (ite any-u 0 1))
;;                                           1)))))
;;      (forall (i$0 n$0) (|| (&& (! i$0) (<= n$0 min-w))
;;                            (! (forall (m$1) (|| (! any-u)
;;                                                 (&& any-u
;;                                                     (&& (! i$0) (<= n$0 (ite any-u
;;                                                                              (+ (ite any-u 0 1) m$1)
;;                                                                              1))))))))))
;;  (&& (forall (w$2) (|| any-u (! (app R m$1 w$2))))
;;      (forall (b$1) (|| (|| (! any-u) b$1)
;;                        (! (forall (w$3) (|| b$1 (! (app R m$1 w$3))))))))
;;  (&& (forall (w$0) (|| any-u (! (app R m$0 w$0))))
;;      (forall (b$0) (|| (|| b$0 (! any-u))
;;                        (! (forall (w$1) (|| b$0 (! (app R m$0 w$1)))))))))

;; (list
;;  (&& (forall (w$0) (|| (! any-u$0)
;;                        (&& any-u$0 (<= min-w$0 (ite any-u$0
;;                                                     (+ w$0 (ite any-u$0 0 1))
;;                                                     1)))))
;;      (forall (i$0 n$0) (|| (&& (! i$0) (<= n$0 min-w$0))
;;                            (! (forall (w$1) (|| (! any-u$1)
;;                                                 (&& any-u$1
;;                                                     (&& (! i$0)
;;                                                         (<= n$0 (ite any-u$1
;;                                                                      (+ w$1 (ite any-u$1 0 1))
;;                                                                      1))))))))))
;;  (&& (forall (w$2) (|| any-u$1 (! (app R$0 w$1 w$2))))
;;      (forall (b$1) (|| (|| b$1 (! any-u$1))
;;                        (! (forall (w$3) (|| b$1 (! (app R$0 w$1 w$3))))))))
;;  (&& (forall (w$0) (|| any-u$0 (! (app R$0 w$0 w$0))))
;;      (forall (b$0) (|| (|| b$0 (! any-u$0))
;;                        (! (forall (w$1) (|| b$0 (! (app R$0 w$0 w$1)))))))))

;; (list
;;  (&& (forall (w$0) (<= min-w$0 min-u$0))
;;      (forall (i$0 n$0) (|| (&& (! i$0) (<= n$0 min-w$0))
;;                            (! (forall (w$3) (&& (! i$0) (<= n$0 min-u$1)))))))
;;  (&& (forall (w$4) (|| (! (app R$0 w$3 w$4))
;;                        (&& (app R$0 w$3 w$4)
;;                            (<= min-u$1 (ite (app R$0 w$3 w$4)
;;                                             (+ w$3 (ite (app R$0 w$3 w$4) 0 1))
;;                                             1)))))
;;      (forall (i$2 n$2) (|| (&& (! i$2) (<= n$2 min-u$1))
;;                            (! (forall (w$5) (|| (! (app R$0 w$3 w$5)) (&& (app R$0 w$3 w$5) (&& ...))))))))
;;  (&& (forall (w$1) (|| (! (app R$0 w$0 w$1))
;;                        (&& (app R$0 w$0 w$1)
;;                            (<= min-u$0 (ite (app R$0 w$0 w$1)
;;                                             (+ w$0 (ite (app R$0 w$0 w$1) 0 1))
;;                                             1)))))
;;      (forall (i$1 n$1) (|| (&& (! i$1) (<= n$1 min-u$0))
;;                            (! (forall (w$2) (|| (! (app R$0 w$0 w$2)) (&& (app R$0 w$0 w$2) (&& ...)))))))))

(define (S-27 R E)
  (define (f x z)
    (define (f0 w2 w1 y w)
      (&& (R x y w1)
          (E y z w2)
          (= w (+ w1 w2))))
    (define (f1 w1 y w)
      (define-symbolic* any-w2 boolean?)
      (assert (lub-b any-w2 (lambda (w2) (f0 w2 w1 y w))))
      any-w2)
    (define (f2 y w)
      (define-symbolic* any-w1 boolean?)
      (assert (lub-b any-w1 (lambda (w1) (f1 w1 y w))))
      any-w1)
    (define (f3 w)
      (define-symbolic* any-y boolean?)
      (assert (lub-b any-y (lambda (y) (f2 y w))))
      (t* (trop #f w) (to-trop any-y)))
    (define (f4)
      (define-symbolic* min-w integer?)
      (assert (trop-lub (trop #f min-w) f3))
      min-w)
    (f4))
  f)

(define (S-28 R E)
  (define (f x z)
    (define (f0 w2 w1 y w)
      (t* (t* (to-trop (R x y w1))
              (to-trop (E y z w2)))
          (t* (to-trop (= w (+ w1 w2)))
              (trop #f w))))
    (define (f1 w1 y w)
      (define-symbolic* min-w2 integer?)
      (assert (trop-lub (trop #f min-w2)
                        (lambda (w2) (f0 w2 w1 y w))))
      (trop #f min-w2))
    (define (f2 y w)
      (define-symbolic* min-w1 integer?)
      (assert (trop-lub (trop #f min-w1)
                        (lambda (w1) (f1 w1 y w))))
      (trop #f min-w1))
    (define (f3 w)
      (define-symbolic* min-y integer?)
      (assert (trop-lub (trop #f min-y)
                        (lambda (y) (f2 y w))))
      (trop #f min-y))
    (define (f4)
      (define-symbolic* min-w integer?)
      (assert (trop-lub (trop #f min-w)
                        (lambda (w) (f3 w))))
      min-w)
    (f4))
  f)

(define (test-27-28)
  (define-symbolic* E R (~> integer? integer? integer? boolean?))
  (define-symbolic* x z integer?)
  (define r1 ((S-27 R E) x z))
  (define r2 ((S-28 R E) x z))
  (verify (assert (eq? r1 r2))))
